---
layout: post
title: 对象初始化的注意事项
categories: [阅读笔记, Effective C++]
date: '2025-06-16 03:02:01 +0800'
---

<span style="font-size: 24px;">**Effective C++ 条款04 ：确定对象被使用前已被初始化**</span>

> C++在某些情况下会自动初始化对象，但并不绝对。
> 
> 使用未初始化的对象将出现未定义行为！
 {: .prompt-danger }

**为内置型对象进行手动初始化，C++并不保证对象的初始化**
<br/>
<br/>

> 初值列中的成员变量排列次序应与其在class中的声明次序一致，避免出现变量依赖问题。
 {: .prompt-info }
**构造函数应使用成员初值列（member initialization list），而非在函数体内使用赋值操作（assignment）。**

```cpp
class A {
public:
    // 声明
    A(const int& x, const bool& y); 

private:
    int a;
    bool b;
};

// 实现
A::A(const int& x, const bool& y) 
    : a(x),   
      b(y)    
{ }

```

*初始化列表 vs 构造函数赋值的对比总结*

| **特性**               | **成员初始化列表**     | **构造函数体内赋值**               |
| ---------------------- | ---------------------- | ---------------------------------- |
| **性能（类类型成员）** | ⭐️ 高效（直接构造）     | ❌ 低效（默认构造+赋值）            |
| **`const`成员支持**    | ⭐️ 必须使用             | ❌ 不支持                           |
| **引用成员支持**       | ⭐️ 必须使用             | ❌ 不支持                           |
| **无默认构造的成员**   | ⭐️ 必须使用             | ❌ 不支持                           |
| **初始化顺序控制**     | ⭐️ 按声明顺序（安全）   | ❌ 按代码顺序（可能引发未定义行为） |
| **代码简洁性**         | ⭐️ 集中初始化，逻辑清晰 | ⚠️ 分散在函数体中                   |

<br/>
<br/>

> C++标准未定义不同编译单元（.cpp文件）中non-local static对象的初始化顺序
。若对象A依赖对象B，而B尚未初始化时A被访问，会导致未定义行为（如访问空指针或未构造的对象）
。
 {: .prompt-danger }
**为了免除“跨编译单元的初始化次序”问题，请以local static对象替换non-local static对象**

```cpp
// 替换前（风险）
extern FileSystem tfs; 

// 替换后（安全）
FileSystem& tfs() { 
    static FileSystem fs; // local static
    return fs; 
}
```

**核心逻辑​：**

**1、​延迟初始化（Lazy Initialization）​​**
local static对象在函数首次被调用时初始化，而非程序启动时
。
→ 避免“未初始化即使用”的问题，依赖方调用函数时对象必然已构造完成
。

**2、​线程安全保证（C++11后）​​**
C++11规定：若多线程同时首次调用函数，仅一个线程执行初始化，其他线程阻塞等待
。
→ 无需手动加锁即可避免重复构造（Magic Static特性）
。

**3、​按需构造，减少开销​**
若从未调用函数，则对象不会被构造，节省资源
。
→ 对比non-local static对象无论是否使用均被初始化。

✅ **替换后的优势**

| **维度**       | **non-local static**           | **local static**（替换后） |
| -------------- | ------------------------------ | -------------------------- |
| **初始化时机** | `main()`前，顺序不确定         | 首次调用时，按需初始化     |
| **线程安全**   | 无竞争（单线程初始化）         | C++11后安全（内置同步）    |
| **封装性**     | 全局可见，易被误修改           | 通过函数访问，限制修改路径 |
| **资源开销**   | 程序启动即初始化，可能浪费资源 | 未调用则不构造，零开销     |
