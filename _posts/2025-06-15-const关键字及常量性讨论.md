---
layout: post
title: const关键字及常量性讨论
categories: [阅读笔记, Effective C++]
date: '2025-06-15 20:37:01 +0800'
---

<span style="font-size: 24px;">**Effective C++ 条款03 ：尽可能使用const**</span>

> 对于任何不需要修改的值和对象使用const关键字可以有效降低因客户错误而造成的意外，
> 而又不至于放弃安全型和高效性
 {: .prompt-tip }

const关键字可用于在classes外部修饰global或namespace作用域中的常量，或修饰文件、函数、或区块作用域（block scope）中被声明为static的对象。也可用于修饰classes内部的static和non-static成员变量。

面对指针，也可只出指针自身及所指物是否为const或者两者都是（或都不是）：
```cpp
    char greeting[] = "Hello";
    char* p = greeting;   // non-const pointer, non-const data
    const char* p = greeting;   // non-const pointer, const data
    // const char* p 等价于 char const * p
    char* const p = greeting;   // const pointer, non-const data
    const char* const p = greeting;   // const ponter, const data
```
**const成员函数：**

1、const函数使class接口更易于理解，能够表明哪些函数可以改动对象内容而哪些不行。
  
  > 改善C++程序效率的一个根本办法是以pass by reference-to-const方式传递对象，而此技术的前提是，我们有const成员函数用于处理取得的const对象。
 {: .prompt-info }

2、const函数使得操作const对象成为可能。

3、const函数以及操作符可以进行重载对不同版本给予返回const/non-const的类型

  > 重载non-const函数时应使用static_cast将non-const对象转为const对象并调用const函数，再利用const_cast将返回值的const属性移除的方式，而不能反向操作。
 {: .prompt-warning }

4、调用const函数重载实质等价的non-const函数可以避免代码重复减少代码冗余
<br/>
<br/>
<span style="font-size: 24px;">**以下是常量性讨论：**</span>

<br/>
在编程和逻辑学中，“位常量性”（bitwise constness）、“逻辑常量性”（logical constness）和“概念常量性”（conceptual constness）代表了三种不同层次的常量性理念，分别对应物理存储、语义行为和抽象契约三个维度。以下结合技术实践和理论背景展开分析：

**🧱 ​一、概念常量性（Conceptual Constness）​​**

​定义​：常量在概念层面的不变性，即标识符与值的绑定关系不可改变
。这是常量最基础的定义，强调“名值绑定”的不可变性。
​核心特征​：

​绑定不可变​：常量标识符一旦初始化，其指向的值或对象引用不可更改（如C++中的const int或Java的final变量）
。
​作用范围​：
基本类型（如int, char）：值不可变。
复合类型（如对象、数组）：引用不可变，但对象内部状态可能可变（如Java的final List可修改元素）
。
​技术实现​：
语言机制：通过const（C++）、final（Java）、const（JavaScript）等关键字声明
。
​示例​：

```cpp
const int MAX_SIZE = 100;  // 值不可变
const std::vector<int> data{1, 2, 3}; // 引用不可变，但元素可修改（需额外const修饰）
```

**💾 ​二、位常量性（Bitwise Constness）​​**

​定义​：物理存储层面的不变性，要求对象在const成员函数中不修改任何非mutable成员变量的比特位
。
​核心特征​：

​物理不可变​：const成员函数内禁止修改对象内存布局（编译器静态检查）
。
​局限​：可能违反逻辑不变性（如指针指向的数据被修改）。
​典型问题​：

```cpp
class Buffer {
    char* data;
public:
    char getByte(int idx) const {
        return data[idx]; // 合法：未修改成员指针的比特位
    }
    void modifyData(int idx) const {
        data[idx] = 0;    // ⚠️ 合法但危险：未改指针，但修改了指向内容！
    }
};
```
此处modifyData满足位常量性（指针地址未变），但破坏了逻辑常量性（外部可见状态改变）。

**🧠 ​三、逻辑常量性（Logical Constness）​​**

​定义​：语义层面的不变性，要求const成员函数不改变对象的外部可观测状态，但允许修改内部辅助状态（如缓存、计数器）
。
​核心特征​：

​语义不变性​：用户视角的对象行为保持一致（如矩形的getArea()不改变尺寸）
。
​技术实现​：
使用mutable成员（如缓存标记、统计计数）。
通过封装隐藏内部状态变化。
​示例​：
```cpp
class Cache {
    mutable bool isValid{false}; // mutable：允许在const函数中修改
    mutable int cachedValue;
public:
    int compute() const {
        if (!isValid) {
            cachedValue = heavyCalculation(); // ✅ 修改mutable成员
            isValid = true;
        }
        return cachedValue;
    }
};
```
此处compute()满足逻辑常量性：外部调用者感知结果不变，但内部缓存可更新。

📊 ​三者的对比与关联​

| **​维度** | **​概念常量性**    | **​位常量性**           | **逻辑常量性**​      |
| --------- | ------------------ | ----------------------- | -------------------- |
| 关注点    | 标识符绑定关系     | 对象物理存储            | 对象外部行为一致性   |
| ​核心要求 | 名值绑定不可变     | 内存比特位不可变        | 语义状态不可观测改变 |
| ​实现机制 | 语言级常量声明     | 编译器静态检查          | mutable成员/封装     |
| ​典型问题 | 对象内部可变性     | 指针/引用数据的间接修改 | 缓存更新、延迟初始化 |
| ​适用场景 | 基本类型、接口常量 | 低层内存安全            | 高性能计算、状态管理 |

**⚖️ ​四、设计实践中的取舍​**

​安全性优先​：
对内存安全要求高的场景（如嵌入式系统）倾向位常量性，避免意外修改
。
​功能与性能平衡​：
  逻辑常量性通过mutable支持缓存、原子计数等，提升const函数的实用性（如STL的std::string::size()缓存长度）
。
​抽象契约维护​：
  概念常量性确保API契约清晰（如React组件的props不可变），避免副作用。

**💎 ​总结​**

常量性在编程中不是单一概念，而是从物理存储​（位常量性）、语义行为​（逻辑常量性）到抽象契约​（概念常量性）的多层约束：

·​位常量性是编译器的底层保障，但可能掩盖逻辑错误；

·​逻辑常量性平衡了功能与安全，是C++等语言的核心实践；

·​概念常量性定义用户与系统的契约，是架构设计的基石。
  
  理解三者差异，能更精准地设计常量接口，兼顾性能、安全与封装性。


